[
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Student Projects",
    "section": "",
    "text": "Explore featured student and faculty research projects.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAI-Based Rice Disease Detection\n\n\n\n\n\n\n\n\nMar 1, 2025\n\n\nJane Doe\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Blog",
    "section": "",
    "text": "Our blog shares tutorials, news, and reflections from the department.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTree\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Department of Data Science\nWelcome to our official page!\nStay up to date with our latest research, student projects, and announcements."
  },
  {
    "objectID": "announcements/2025-05-13-new-lab.html",
    "href": "announcements/2025-05-13-new-lab.html",
    "title": "New AI Lab Opened",
    "section": "",
    "text": "We are excited to announce the opening of our new AI Research Lab in Room 301. The lab is equipped with high-performance GPUs and collaborative workstations."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Us",
    "section": "",
    "text": "The Department of Data Science at Our College focuses on cutting-edge education and research in machine learning, data analytics, and AI.\nWe aim to bridge theory and practice by fostering interdisciplinary projects and innovation."
  },
  {
    "objectID": "announcements/index.html",
    "href": "announcements/index.html",
    "title": "Announcements",
    "section": "",
    "text": "Here you’ll find the latest announcements from the Department of Data Science.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNew AI Lab Opened\n\n\n\n\n\n\n\n\nMay 13, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/blog-welcome.html",
    "href": "posts/blog-welcome.html",
    "title": "Tree",
    "section": "",
    "text": "Instructor: Jhun Brian M. Andam\nCourse: Data Structures and Algorithm\nObjectives\n\nLearn how tree data structure works.\nImplement trees in python.\nExplore, understand, and implement different kind of trees in different use cases.\n\nA tree data structure is a hierarchical model used to organize data in a parent-child relationship, resembling an inverted tree. It consists of nodes connected by edges, where the topmost node is called the root, and each node may have zero or more child nodes. Nodes without children are called leaves. Unlike linear data structures such as arrays or linked lists, trees allow for more efficient searching, insertion, and deletion operations in certain cases, especially when dealing with hierarchical data like file systems, organizational structures, or decision processes. Each tree must be connected and acyclic, meaning there is exactly one path between any two nodes. Specialized types of trees include binary trees, where each node has at most two children, and binary search trees, which maintain a specific order among elements to allow fast lookup operations.\n\nComponents of a Tree\n\n\n\n\nParent Node: The node which is an immediate predecessor of a node is called the parent node of that node.\nChild Node: The node which is the immediate successor of a node is called the child node of that node..\nRoot Node: The topmost node of a tree or the node which does not have any parent node is called the root node. A non-empty tree must contain exactly one root node and exactly one path from the root to all other nodes of the tree.\nLeaf Node or External Node: The nodes which do not have any child nodes are called leaf nodes.\nAncestor of a Node: Any predecessor nodes on the path of the root to that node are called Ancestors of that node.\nDescendant: A node x is a descendant of another node y if and only if y is an ancestor of x.\nSibling: Children of the same parent node are called siblings.\nLevel of a node: The count of edges on the path from the root node to that node.\nInternal node: A node with at least one child is called Internal Node.\nNeighbour of a Node: Parent or child nodes of that node are called neighbors of that node.\nSubtree: Any node of the tree along with its descendant.\n\n\n\nCommon Types of Tree Data Structures\n\nN-Ary Tree. A general tree where each node can have up to N children (not limited to two as in binary trees). This type of tree is useful for representing hierarchical structures like organizational charts, XML/HTML documents, or category trees.\nBinary Tree. A tree data structure where each node has at most two children, commonly referred to as the left child and right child. It’s the foundation for more advanced tree types but does not enforce any specific ordering of elements.\nBinary Search Trees. A type of binary tree where the left child contains values less than the parent node, and the right child contains values greater than the parent. This structure allows for efficient O(log n) time complexity for search, insertion, and deletion—if the tree remains balanced.\nAVL Tree. A self-balancing binary search tree where the difference in height (balance factor) between the left and right subtrees of any node is no more than one. If the balance factor goes out of this range, rotations are performed to restore balance, ensuring logarithmic time complexity for operations.\n\n\n\nCommon Operations in Tree ADT\n\ninsert(parent, value) – Adds a new node to the tree.\ndelete(value) – Removes a node from the tree.\nsearch(value) – Checks if a value exists in the tree.\ntraverse() – Visits all nodes (e.g., pre-order, in-order, post-order).\nfindParent(node) – Returns the parent of a given node.\nfindChildren(node) – Returns the children of a given node.\n\n\n\nImplementation\n\nclass GTNode:\n    def __init__(self, data):\n        self.data = data\n        self.children = []\n\nclass BTNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\nclass Node:\n    def __init__(self, data, node_type='gt'):\n        self.data = data\n        self.node_type = node_type\n\n        if node_type == 'bt':\n            self.left = None\n            self.right = None\n        elif node_type == 'gt':\n            self.children = []\n        else:\n            raise ValueError(\"node_type must be either 'general' or 'binary'\")\n\n    def __repr__(self):\n        return str(self.data)\n\nNode class will be used to create nodes for N-Ary Tree aka general trees and Binary Tree.\n\nclass GTree:\n    def __init__(self, root_data):\n        self.root = Node(root_data, node_type='gt') # is an instance of class Node\n\nclass BTree:\n    def __init__(self, root_data):\n        self.root = Node(root_data, node_type='bt')\n\nGTree and BTree will be used as the initial to structure for Tree ADT.\n\n\nN-Ary\nA general tree where each node can have up to N children (not limited to two as in binary trees).\nOur goal is to make a tree that looks like this.\n\n\n\n\n# root node\ngtree = GTree('rootsss') # this is already a tree or initial form sa tree\n\n# children nodes\nimgs = Node('images') # node instances\nmsks = Node('masks')\n\n# add the instantaited children nodes to the root node\ngtree.root.children.append(imgs)\ngtree.root.children.append(msks)\n\n# et voila! that's how we create a tree :&gt;\n\nSince tree nodes are not stored in a linear fashion, we need systematic methods to access each node. These methods are called tree traversal techniques, and they define the order in which we visit the nodes. Depending on the application, different traversal orders (like in-order, pre-order, post-order, or level-order) may be more suitable.\nTraversal Methods\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSearch Type\nApproach\nUses Stack/Queue\nOrder of Visit\nBest Use Case\nComplexity (Average/Worst)\n\n\n\n\nDFS (Preorder)\nRecursive/Iterative\nStack (explicit or implicit via recursion)\nRoot → Children (left to right)\nGeneral tree search, early exit possible\n\\(O(n)\\) / \\(O(n)\\)\n\n\nDFS (Inorder)\nBinary trees only\nStack (implicit or explicit)\nLeft → Root → Right\nBinary Search Trees for sorted data\n\\(O(log n)\\) / \\(O(n)\\)\n\n\nDFS (Postorder)\nRecursive/Iterative\nStack\nChildren → Root\nDeleting nodes, evaluating expressions\n\\(O(n)\\) / \\(O(n)\\)\n\n\nBFS (Level-order)\nIterative\nQueue\nLevel by level, left to right\nFinding shortest path in unweighted trees\n\\(O(n)\\) / \\(O(n)\\)\n\n\nBinary Search (BST)\nRecursive/Iterative\nNo extra structure\nDepends on key comparisons\nSearching in Binary Search Trees\n\\(O(log n)\\) / \\(O(n)\\)\n\n\n\n\n   \n\n\npreorder\nparent -&gt; children(left to right)\n\n\ndef preorder(node):\n    yield node.data\n    for child in node.children:\n        yield from preorder(child)\n\n\n[i for i in preorder(gtree.root)]\n\n['rootsss', 'images', 'masks']\n\n\n\npostorder\nchildren(left to right) -&gt; parent\n\n\ndef postorder(node):\n    for child in node.children:\n        yield from postorder(child)\n    yield node.data\n\n\n[i for i in postorder(gtree.root)]\n\n['images', 'masks', 'rootsss']\n\n\n\nlevelorder\nlevel by level (left to right)\n\n\ndef levelorder(node):\n    queue = [node]\n    while queue:\n        n = queue.pop(0)\n        yield n.data\n        queue.extend(n.children)\n\n\n[i for i in levelorder(gtree.root)]\n\n['rootsss', 'images', 'masks']\n\n\nInsert\n\nx_train = Node('x_train') # images\ny_train = Node('y_train') # masks\nx_test = Node('x_test') # images\ny_test = Node('y_test') # masks\n\nWe are adding more nodes to the tree structure. Since we already know the specific parent node to which each child should be assigned, traversal is not required in this case.\n\ndef insert(parent, node):\n    parent.children.append(node)\n\n\ngtree.root.children[0].children.append(x_train)\ngtree.root.children[0].children.append(x_test)\n\ngtree.root.children[1].children.append(y_train)\ngtree.root.children[1].children.append(y_test)\n\n\n# images\n# insert(gtree.root.children[0], x_train)\n# insert(gtree.root.children[0], x_test)\n\n# # masks\n# insert(gtree.root.children[1], y_train)\n# insert(gtree.root.children[1], y_test)\n\nDisplay Function\n\ndef print_tree(node, level=0):\n    print(\" \" * (level * 2) + str(node.data))\n    for child in node.children:\n        print_tree(child, level + 1)\n\n\nprint_tree(gtree.root)\n\nrootsss\n  images\n    x_train\n    x_test\n  masks\n    y_train\n    y_test\n\n\nWe compile the traversal methods in this class, the traversal methods defined here are only applicable for N-Ary trees.\n\nclass Traverse:\n    def __init__(self, node):\n        self.node = node\n\n    def preorder(self):\n        def _preorder(node):\n            yield node.data\n            for child in node.children:\n                yield from _preorder(child)\n        return _preorder(self.node)\n\n    def postorder(self):\n        def _postorder(node):\n            for child in node.children:\n                yield from _postorder(child)\n            yield node.data\n        return _postorder(self.node)\n\n    def levelorder(self):\n        queue = [self.node]\n        while queue:\n            n = queue.pop(0)\n            yield n.data\n            queue.extend(n.children)\n\n\n\n\n\ntobj = Traverse(gtree.root)\n\n\n[i for i in tobj.postorder()]\n\n['x_train', 'x_test', 'images', 'y_train', 'y_test', 'masks', 'rootsss']\n\n\n\n\n\nThink:\n\n\n\nWhat will be the output if we execute the following codes?\n\n   [i for i in tobj.preorder()]\n   [i for i in tobj.postorder()]\n   [i for i in tobj.levelorder()]\n\n\n\n\n\n\nHomework Activity:\n\n\nIn this lab activity, you’ll apply your understanding of tree structures and traversal by implementing some fundamental operations in an N-ary tree:\n\nsearch(root, data) – Locate a specific node in the tree, returns True if data in tree, else, False.\ndelete(node) – Remove a single node while preserving tree structure.\ndelete_subtree(node) – Remove a node and all of its descendants.\nfind_parent(node) – Identify the parent of a given node (assuming no direct parent reference).\n\nReplicate the figure below, you may use the Traverse class for this. Comment each line of code in conyo or bisaya.\nNO comment, NO score\n\n\n\nAfter you implement, answer the following questions.\n\nWhat are your realizations after implementing the Tree methods?\nWhich operation did you find most challenging to implement, and why?\nIn what real-world applications might N-ary trees be used?\nDid using traversal help make your code more organized or efficient? Explain.\nIf given a very large tree, which traversal method would you choose for searching and why?\n\n\n\n\nBinary Tree\n\n\n\n\n\n\n\n\nFeature\nBinary Tree\nN-ary Tree (General Tree)\n\n\n\n\nNumber of Children\nMaximum of 2 children per node\nUp to N children per node (no fixed maximum)\n\n\nChild Pointers\nUsually left and right attributes\nUsually a children list\n\n\nTree Traversals\nInorder, Preorder, Postorder, Level-order\nPreorder, Postorder, Level-order\n\n\nUse Cases\nBinary Search Tree, Heap, Expression Tree\nFile systems, Game trees, Organizational charts\n\n\nSimplicity\nEasier to implement and reason about\nMore flexible but requires list-based handling\n\n\nMemory Usage\nFixed pointer structure (left/right)\nMay use dynamic memory (e.g., lists of children)\n\n\nCommon Variants\nBST, AVL, Red-Black, Heap\nTrie, Quad Tree, B-Tree, etc.\n\n\nTraversal Efficiency\nSimpler recursive or iterative methods\nNeeds generalized recursion or queue handling\n\n\n\nBinary tree shares the same methods with N-Ary tree but teh implementation should be explicit for binary trees.\n\nbtree = BTree('alpha')\n\nl = Node('beta', node_type='bt')\nr = Node('gamma', node_type='bt')\n\nbtree.root.left = l\nbtree.root.right = r\n\nll = Node('delta', node_type='bt')\nlr = Node('epsilon', node_type='bt')\n\nbtree.root.left.left = ll\nbtree.root.left.right = lr\n\nWe modified the print_method() above to accommodate Binary Trees, where children are stored as individual variables (e.g., left and right) rather than as a collection like in N-Ary Trees.\n\ndef print_btree(root, level=0, prefix=\"Root: \"):\n    if root is not None:\n        print(\" \" * (level * 4) + prefix + str(root.data))\n        if root.left is not None or root.right is not None:\n            if root.left:\n                print_btree(root.left, level + 1, \"L--- \")\n            if root.right:\n                print_btree(root.right, level + 1, \"R--- \")\n\n\nprint_btree(btree.root)\n\nRoot: alpha\n    L--- beta\n        L--- delta\n        R--- epsilon\n    R--- gamma\n\n\nInorder traversal is only applicable to binary trees because it relies on the concept of visiting the left child, then the current node, and finally the right child — a structure that only binary trees follow.\n\ndef inorder(root):\n    if root is None:\n        return\n    yield from inorder(root.left)\n    yield root.data\n    yield from inorder(root.right)\n\n\n[i for i in inorder(btree.root)]\n\n['delta', 'beta', 'epsilon', 'alpha', 'gamma']"
  },
  {
    "objectID": "projects/ai-thesis-2025.html",
    "href": "projects/ai-thesis-2025.html",
    "title": "AI-Based Rice Disease Detection",
    "section": "",
    "text": "This project uses U-Net with a ResNet34 backbone to detect diseases in rice leaves.\nIt achieved an IoU of 0.84 on a validation dataset and supports smallholder farmers."
  }
]