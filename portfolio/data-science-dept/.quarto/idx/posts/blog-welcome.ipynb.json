{"title":"**Tree**","markdown":{"yaml":{"title":"**Tree**"},"headingText":"**Components of a Tree**","containsRefs":false,"markdown":"\n\n\n\n\n**Instructor:** Jhun Brian M. Andam\n\n**Course:** Data Structures and Algorithm\n\n**Objectives**\n\n- Learn how tree data structure works.\n- Implement trees in python.\n- Explore, understand, and implement different kind of trees in different use cases.\n\n\n\nA **tree data structure** is a hierarchical model used to organize data in a parent-child relationship, resembling an inverted tree. It consists of nodes connected by edges, where the topmost node is called the root, and each node may have zero or more child nodes. Nodes without children are called leaves. Unlike linear data structures such as arrays or linked lists, trees allow for more efficient searching, insertion, and deletion operations in certain cases, especially when dealing with hierarchical data like file systems, organizational structures, or decision processes. Each tree must be connected and acyclic, meaning there is exactly one path between any two nodes. Specialized types of trees include binary trees, where each node has at most two children, and binary search trees, which maintain a specific order among elements to allow fast lookup operations.\n\n\n<center><img src=\"https://media.geeksforgeeks.org/wp-content/uploads/20250214120937877633/treeTerminologies.webp\" width=\"500px\"></center>\n\n1. **Parent Node**: The node which is an immediate predecessor of a node is called the parent node of that node.\n2. **Child Node**: The node which is the immediate successor of a node is called the child node of that node..\n3. **Root Node**: The topmost node of a tree or the node which does not have any parent node is called the root node. A non-empty tree must contain exactly one root node and exactly one path from the root to all other nodes of the tree.\n4. **Leaf Node or External Node**: The nodes which do not have any child nodes are called leaf nodes.\n5. **Ancestor of a Node**: Any predecessor nodes on the path of the root to that node are called Ancestors of that node.\n6. **Descendant**: A node `x` is a `descendant of` another node `y` **if and only if** `y` is `an ancestor` of `x`.\n7. **Sibling**: Children of the same parent node are called siblings.\n8. **Level of a node**: The count of edges on the path from the root node to that node.\n9. **Internal node**: A node with at least one child is called Internal Node.\n10. **Neighbour of a Node**: Parent or child nodes of that node are called neighbors of that node.\n11. **Subtree**: Any node of the tree along with its descendant.\n\n### **Common Types of Tree Data Structures**\n\n1. **N-Ary Tree**. A general tree where each node can have up to N children (not limited to two as in binary trees). This type of tree is useful for representing hierarchical structures like organizational charts, XML/HTML documents, or category trees.\n2. **Binary Tree**. A tree data structure where each node has at most two children, commonly referred to as the left child and right child. **It's the foundation for more advanced tree types** but does not enforce any specific ordering of elements.\n3. **Binary Search Trees**. A type of binary tree where the left child contains values less than the parent node, and the right child contains values greater than the parent. This structure allows for efficient O(log n) time complexity for search, insertion, and deletion—if the tree remains balanced.\n4. **AVL Tree**. A self-balancing binary search tree where the difference in height (balance factor) between the left and right subtrees of any node is no more than one. If the balance factor goes out of this range, rotations are performed to restore balance, ensuring logarithmic time complexity for operations.\n\n### **Common Operations in Tree ADT**\n\n- `insert(parent, value)` – Adds a new node to the tree.\n- `delete(value)` – Removes a node from the tree.\n- `search(value)` – Checks if a value exists in the tree.\n- `traverse()` – Visits all nodes (e.g., pre-order, in-order, post-order).\n- `findParent(node)` – Returns the parent of a given node.\n- `findChildren(node)` – Returns the children of a given node.\n\n### **Implementation**\n\n`Node` class will be used to create nodes for `N-Ary Tree` aka general trees and `Binary Tree`.\n\n`GTree` and `BTree` will be used as the initial to structure for Tree ADT.\n\n### **N-Ary**\n\nA general tree where each node can have up to N children (not limited to two as in binary trees).\n\nOur goal is to make a tree that looks like this.\n<center><img src=\"figures/tree.drawio.png\" width=\"200px\"></center>\n\nSince tree nodes are not stored in a linear fashion, we need systematic methods to access each node. These methods are called tree traversal techniques, and they define the order in which we visit the nodes. Depending on the application, different traversal orders (like in-order, pre-order, post-order, or level-order) may be more suitable.\n\n**Traversal Methods**\n\n<center><img src=\"https://miro.medium.com/v2/resize:fit:956/1*7oIYbZPNlSSwS4qnz-Di6g.png\" width=\"650px\"></center>\n\n| Search Type         | Approach      | Uses Stack/Queue | Order of Visit        | Best Use Case                                  | Complexity (Average/Worst) |\n|---------------------|---------------|------------------|------------------------|------------------------------------------------|-----------------------------|\n| DFS (Preorder)      | Recursive/Iterative | Stack (explicit or implicit via recursion) | Root → Children (left to right) | General tree search, early exit possible        | $O(n)$ / $O(n)$                 |\n| DFS (Inorder)       | Binary trees only | Stack (implicit or explicit)     | Left → Root → Right         | Binary Search Trees for sorted data             | $O(log n)$ / $O(n)$             |\n| DFS (Postorder)     | Recursive/Iterative | Stack                          | Children → Root              | Deleting nodes, evaluating expressions          | $O(n)$ / $O(n)$                 |\n| BFS (Level-order)   | Iterative     | Queue                           | Level by level, left to right| Finding shortest path in unweighted trees       | $O(n)$ / $O(n)$                 |\n| Binary Search (BST) | Recursive/Iterative | No extra structure             | Depends on key comparisons   | Searching in Binary Search Trees                | $O(log n)$ / $O(n)$             |\n\n\n<center>\n  <a href=\"https://youtu.be/WLvU5EQVZqY\">\n    <img class=\"thumbnail\" \n         src=\"https://i.ytimg.com/vi/WLvU5EQVZqY/hq720.jpg\" \n         alt=\"YouTube Thumbnail\" \n         width=\"500px\">\n  </a>\n    <img src=\"figures/traversal.png\" width=\"350px\">\n</center>\n\n- **preorder**\n- `parent -> children(left to right)`\n\n- **postorder**\n- `children(left to right) -> parent`\n\n- **levelorder**\n- `level by level (left to right)`\n\n**Insert**\n\nWe are adding more nodes to the tree structure. Since we already know the specific parent node to which each child should be assigned, traversal is not required in this case.\n\n**Display Function**\n\nWe compile the traversal methods in this class, the traversal methods defined here are only applicable for N-Ary trees.\n\n<center><img src=\"figures/tree.drawio2.png\" width=\"400px\"></center>\n\n<div class=\"alert alert-block alert-warning\"><b><h3>Think: </h3></b>\n\n1. What will be the output if we execute the following codes?\n    - ```python\n      [i for i in tobj.preorder()]\n      ```\n    - ```python\n      [i for i in tobj.postorder()]\n      ```\n    - ```python\n      [i for i in tobj.levelorder()]\n      ```\n</div>\n\n<div class=\"alert alert-block alert-warning\"><b><h3>Homework Activity: </h3></b>\n    \nIn this lab activity, you’ll apply your understanding of tree structures and traversal by implementing some fundamental operations in an N-ary tree:\n\n- `search(root, data)` – Locate a specific node in the tree, returns True if data in tree, else, False.\n- `delete(node)` – Remove a single node while preserving tree structure.\n- `delete_subtree(node)` – Remove a node and all of its descendants.\n- `find_parent(node)` – Identify the parent of a given node (assuming no direct parent reference).\n\nReplicate the figure below, you may use the `Traverse` class for this. Comment each line of code in `conyo or bisaya`.\n\nNO comment, NO score\n\n<center><img src=\"figures/tree-Page-2.drawio.png\"></center>\n\nAfter you implement, answer the following questions.\n\n1. What are your realizations after implementing the Tree methods?\n2. Which operation did you find most challenging to implement, and why?\n3. In what real-world applications might N-ary trees be used?\n4. Did using traversal help make your code more organized or efficient? Explain.\n5. If given a very large tree, which traversal method would you choose for searching and why?\n</div>\n\n### **Binary Tree**\n\n| Feature                      | Binary Tree                                  | N-ary Tree (General Tree)                         |\n|-----------------------------|----------------------------------------------|---------------------------------------------------|\n| **Number of Children**      | Maximum of 2 children per node               | Up to N children per node (no fixed maximum)      |\n| **Child Pointers**          | Usually `left` and `right` attributes        | Usually a `children` list                         |\n| **Tree Traversals**         | Inorder, Preorder, Postorder, Level-order    | Preorder, Postorder, Level-order                  |\n| **Use Cases**               | Binary Search Tree, Heap, Expression Tree    | File systems, Game trees, Organizational charts   |\n| **Simplicity**              | Easier to implement and reason about         | More flexible but requires list-based handling    |\n| **Memory Usage**            | Fixed pointer structure (left/right)         | May use dynamic memory (e.g., lists of children)  |\n| **Common Variants**         | BST, AVL, Red-Black, Heap                    | Trie, Quad Tree, B-Tree, etc.                     |\n| **Traversal Efficiency**    | Simpler recursive or iterative methods       | Needs generalized recursion or queue handling     |\n\n\nBinary tree shares the same methods with N-Ary tree but teh implementation should be explicit for binary trees.\n\nWe modified the `print_method()` above to accommodate Binary Trees, where children are stored as individual variables (e.g., `left` and `right`) rather than as a collection like in N-Ary Trees.\n\nInorder traversal is only applicable to binary trees because it relies on the concept of visiting the left child, then the current node, and finally the right child — a structure that only binary trees follow.\n","srcMarkdownNoYaml":"\n\n\n\n\n**Instructor:** Jhun Brian M. Andam\n\n**Course:** Data Structures and Algorithm\n\n**Objectives**\n\n- Learn how tree data structure works.\n- Implement trees in python.\n- Explore, understand, and implement different kind of trees in different use cases.\n\n\n\nA **tree data structure** is a hierarchical model used to organize data in a parent-child relationship, resembling an inverted tree. It consists of nodes connected by edges, where the topmost node is called the root, and each node may have zero or more child nodes. Nodes without children are called leaves. Unlike linear data structures such as arrays or linked lists, trees allow for more efficient searching, insertion, and deletion operations in certain cases, especially when dealing with hierarchical data like file systems, organizational structures, or decision processes. Each tree must be connected and acyclic, meaning there is exactly one path between any two nodes. Specialized types of trees include binary trees, where each node has at most two children, and binary search trees, which maintain a specific order among elements to allow fast lookup operations.\n\n### **Components of a Tree**\n\n<center><img src=\"https://media.geeksforgeeks.org/wp-content/uploads/20250214120937877633/treeTerminologies.webp\" width=\"500px\"></center>\n\n1. **Parent Node**: The node which is an immediate predecessor of a node is called the parent node of that node.\n2. **Child Node**: The node which is the immediate successor of a node is called the child node of that node..\n3. **Root Node**: The topmost node of a tree or the node which does not have any parent node is called the root node. A non-empty tree must contain exactly one root node and exactly one path from the root to all other nodes of the tree.\n4. **Leaf Node or External Node**: The nodes which do not have any child nodes are called leaf nodes.\n5. **Ancestor of a Node**: Any predecessor nodes on the path of the root to that node are called Ancestors of that node.\n6. **Descendant**: A node `x` is a `descendant of` another node `y` **if and only if** `y` is `an ancestor` of `x`.\n7. **Sibling**: Children of the same parent node are called siblings.\n8. **Level of a node**: The count of edges on the path from the root node to that node.\n9. **Internal node**: A node with at least one child is called Internal Node.\n10. **Neighbour of a Node**: Parent or child nodes of that node are called neighbors of that node.\n11. **Subtree**: Any node of the tree along with its descendant.\n\n### **Common Types of Tree Data Structures**\n\n1. **N-Ary Tree**. A general tree where each node can have up to N children (not limited to two as in binary trees). This type of tree is useful for representing hierarchical structures like organizational charts, XML/HTML documents, or category trees.\n2. **Binary Tree**. A tree data structure where each node has at most two children, commonly referred to as the left child and right child. **It's the foundation for more advanced tree types** but does not enforce any specific ordering of elements.\n3. **Binary Search Trees**. A type of binary tree where the left child contains values less than the parent node, and the right child contains values greater than the parent. This structure allows for efficient O(log n) time complexity for search, insertion, and deletion—if the tree remains balanced.\n4. **AVL Tree**. A self-balancing binary search tree where the difference in height (balance factor) between the left and right subtrees of any node is no more than one. If the balance factor goes out of this range, rotations are performed to restore balance, ensuring logarithmic time complexity for operations.\n\n### **Common Operations in Tree ADT**\n\n- `insert(parent, value)` – Adds a new node to the tree.\n- `delete(value)` – Removes a node from the tree.\n- `search(value)` – Checks if a value exists in the tree.\n- `traverse()` – Visits all nodes (e.g., pre-order, in-order, post-order).\n- `findParent(node)` – Returns the parent of a given node.\n- `findChildren(node)` – Returns the children of a given node.\n\n### **Implementation**\n\n`Node` class will be used to create nodes for `N-Ary Tree` aka general trees and `Binary Tree`.\n\n`GTree` and `BTree` will be used as the initial to structure for Tree ADT.\n\n### **N-Ary**\n\nA general tree where each node can have up to N children (not limited to two as in binary trees).\n\nOur goal is to make a tree that looks like this.\n<center><img src=\"figures/tree.drawio.png\" width=\"200px\"></center>\n\nSince tree nodes are not stored in a linear fashion, we need systematic methods to access each node. These methods are called tree traversal techniques, and they define the order in which we visit the nodes. Depending on the application, different traversal orders (like in-order, pre-order, post-order, or level-order) may be more suitable.\n\n**Traversal Methods**\n\n<center><img src=\"https://miro.medium.com/v2/resize:fit:956/1*7oIYbZPNlSSwS4qnz-Di6g.png\" width=\"650px\"></center>\n\n| Search Type         | Approach      | Uses Stack/Queue | Order of Visit        | Best Use Case                                  | Complexity (Average/Worst) |\n|---------------------|---------------|------------------|------------------------|------------------------------------------------|-----------------------------|\n| DFS (Preorder)      | Recursive/Iterative | Stack (explicit or implicit via recursion) | Root → Children (left to right) | General tree search, early exit possible        | $O(n)$ / $O(n)$                 |\n| DFS (Inorder)       | Binary trees only | Stack (implicit or explicit)     | Left → Root → Right         | Binary Search Trees for sorted data             | $O(log n)$ / $O(n)$             |\n| DFS (Postorder)     | Recursive/Iterative | Stack                          | Children → Root              | Deleting nodes, evaluating expressions          | $O(n)$ / $O(n)$                 |\n| BFS (Level-order)   | Iterative     | Queue                           | Level by level, left to right| Finding shortest path in unweighted trees       | $O(n)$ / $O(n)$                 |\n| Binary Search (BST) | Recursive/Iterative | No extra structure             | Depends on key comparisons   | Searching in Binary Search Trees                | $O(log n)$ / $O(n)$             |\n\n\n<center>\n  <a href=\"https://youtu.be/WLvU5EQVZqY\">\n    <img class=\"thumbnail\" \n         src=\"https://i.ytimg.com/vi/WLvU5EQVZqY/hq720.jpg\" \n         alt=\"YouTube Thumbnail\" \n         width=\"500px\">\n  </a>\n    <img src=\"figures/traversal.png\" width=\"350px\">\n</center>\n\n- **preorder**\n- `parent -> children(left to right)`\n\n- **postorder**\n- `children(left to right) -> parent`\n\n- **levelorder**\n- `level by level (left to right)`\n\n**Insert**\n\nWe are adding more nodes to the tree structure. Since we already know the specific parent node to which each child should be assigned, traversal is not required in this case.\n\n**Display Function**\n\nWe compile the traversal methods in this class, the traversal methods defined here are only applicable for N-Ary trees.\n\n<center><img src=\"figures/tree.drawio2.png\" width=\"400px\"></center>\n\n<div class=\"alert alert-block alert-warning\"><b><h3>Think: </h3></b>\n\n1. What will be the output if we execute the following codes?\n    - ```python\n      [i for i in tobj.preorder()]\n      ```\n    - ```python\n      [i for i in tobj.postorder()]\n      ```\n    - ```python\n      [i for i in tobj.levelorder()]\n      ```\n</div>\n\n<div class=\"alert alert-block alert-warning\"><b><h3>Homework Activity: </h3></b>\n    \nIn this lab activity, you’ll apply your understanding of tree structures and traversal by implementing some fundamental operations in an N-ary tree:\n\n- `search(root, data)` – Locate a specific node in the tree, returns True if data in tree, else, False.\n- `delete(node)` – Remove a single node while preserving tree structure.\n- `delete_subtree(node)` – Remove a node and all of its descendants.\n- `find_parent(node)` – Identify the parent of a given node (assuming no direct parent reference).\n\nReplicate the figure below, you may use the `Traverse` class for this. Comment each line of code in `conyo or bisaya`.\n\nNO comment, NO score\n\n<center><img src=\"figures/tree-Page-2.drawio.png\"></center>\n\nAfter you implement, answer the following questions.\n\n1. What are your realizations after implementing the Tree methods?\n2. Which operation did you find most challenging to implement, and why?\n3. In what real-world applications might N-ary trees be used?\n4. Did using traversal help make your code more organized or efficient? Explain.\n5. If given a very large tree, which traversal method would you choose for searching and why?\n</div>\n\n### **Binary Tree**\n\n| Feature                      | Binary Tree                                  | N-ary Tree (General Tree)                         |\n|-----------------------------|----------------------------------------------|---------------------------------------------------|\n| **Number of Children**      | Maximum of 2 children per node               | Up to N children per node (no fixed maximum)      |\n| **Child Pointers**          | Usually `left` and `right` attributes        | Usually a `children` list                         |\n| **Tree Traversals**         | Inorder, Preorder, Postorder, Level-order    | Preorder, Postorder, Level-order                  |\n| **Use Cases**               | Binary Search Tree, Heap, Expression Tree    | File systems, Game trees, Organizational charts   |\n| **Simplicity**              | Easier to implement and reason about         | More flexible but requires list-based handling    |\n| **Memory Usage**            | Fixed pointer structure (left/right)         | May use dynamic memory (e.g., lists of children)  |\n| **Common Variants**         | BST, AVL, Red-Black, Heap                    | Trie, Quad Tree, B-Tree, etc.                     |\n| **Traversal Efficiency**    | Simpler recursive or iterative methods       | Needs generalized recursion or queue handling     |\n\n\nBinary tree shares the same methods with N-Ary tree but teh implementation should be explicit for binary trees.\n\nWe modified the `print_method()` above to accommodate Binary Trees, where children are stored as individual variables (e.g., `left` and `right`) rather than as a collection like in N-Ary Trees.\n\nInorder traversal is only applicable to binary trees because it relies on the concept of visiting the left child, then the current node, and finally the right child — a structure that only binary trees follow.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"blog-welcome.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":"cosmo","title":"**Tree**"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}